

``` cpp

// 一个简单的风控流水结构体, 初步测试两个队列的性能
struct RiskFlowData {
  std::string strRiskId;
  std::string strRiskObject;
  double      dRisePx;
  double      dFallPx;
  std::vector<std::string> vecTriggerLog;
};

// int g_riskId = 0;

std::vector<RiskFlowData*> MakeRiskFlowData(int count) {
  int riskId = 0;
  std::vector<RiskFlowData*> vec;

  for (int  i = 0; i < count; ++i) {
    RiskFlowData *data = new RiskFlowData();
    data->strRiskId = std::to_string(++riskId);
    data->strRiskObject = "风控对象_" + data->strRiskId;
    data->dRisePx = 10;
    data->dFallPx = 9;
    auto now = std::chrono::system_clock::now();  
    time_t t = std::chrono::system_clock::to_time_t(now);
    std::stringstream ss;
    ss << std::put_time(localtime(&t), "%y-%m-%d %x");
    std::string format_time = ss.str();
    data->vecTriggerLog.push_back(format_time);

    vec.push_back(data);
  }

  return vec;
}


boost::lockfree::queue<RiskFlowData *> boost_queue(len);
  lockfree_queue<RiskFlowData *> ks_queue(len);

  ankerl::nanobench::Bench bench;
  bench.relative(true);

  bench.run("boost lockfree queue", [&] {
    auto push_func = [&] {
      std::vector<RiskFlowData*> boost_data = MakeRiskFlowData(len);
      for (const auto &v : boost_data) {
        boost_queue.push(v);
      }
    };

    auto pop_func = [&] {
      RiskFlowData *tmp = nullptr;
      while (!boost_queue.pop(tmp)) {
        delete tmp;
        tmp = nullptr;
      }
    };

    std::vector<std::thread> producer_threads;
    std::vector<std::thread> consumer_threads;

    for (int i = 0; i <  2; ++i) {
      producer_threads.emplace_back(push_func);
    }

    for (int i = 0; i <  2; ++i) {
      consumer_threads.emplace_back(pop_func);
    }

    for (auto &t : producer_threads) { t.join(); }
    for (auto &t : consumer_threads) { t.join(); }
  });

  bench.run("ks lockfree queue", [&] {
    auto push_func = [&] {
      std::vector<RiskFlowData*> boost_data = MakeRiskFlowData(len);
      for (const auto &v : boost_data) {
        ks_queue.push(v);
      }
    };

    auto pop_func = [&] {
      RiskFlowData *tmp = nullptr;
      while (!ks_queue.pop(tmp)) {
        delete tmp;
        tmp = nullptr;
      }
    };

    std::vector<std::thread> producer_threads;
    std::vector<std::thread> consumer_threads;

    for (int i = 0; i <  2; ++i) {
      producer_threads.emplace_back(push_func);
    }

    for (int i = 0; i <  2; ++i) {
      consumer_threads.emplace_back(pop_func);
    }

    for (auto &t : producer_threads) { t.join(); }
    for (auto &t : consumer_threads) { t.join(); }
  });
```